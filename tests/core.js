'use strict';
var traverse = require('../');
var chirp = require('../chirp');



describe("Validating traverse() correctly re-generates Expect API expressions from JSON generated by Esprima Parser", function() {

	/// Reusable functions


	function assertify(test){
		return chirp.equal(traverse(test), test);
	}
	///

	/// Tests


	it("Simple equality argument", function() {
		assertify("expect(foo).to.equal('bar');");
	});

	it("Simple type argument", function() {
		assertify("expect('test').to.be.a('string');");
	});

	it("Simple API that does not end in argument", function() {
		assertify("expect(true).to.be.true;");
	});

	it("Simple property argument", function() {
		assertify("expect(foo).to.have.length(3);");
	});

	it('Mutiple MemberExpressions and arguments', function(){
		assertify("expect(tea).to.have.property('flavors').with.length(3);")
	});

	it("Test null", function() {
		assertify("expect(null).to.be.a('null');")
	});

	it("Test undefined", function() {
		assertify("expect(undefined).to.be.an('undefined');")
	});

	it("Simple Object argument", function() {
		assertify("expect({ foo: 'bar' }).to.eql({ foo: 'bar' });");
	});

	it("Object nested in Array", function() {
		assertify("expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);");
	});

	it("Object(s) nested in Array", function() {
		assertify("expect([{ id: 1 }, {id: 2}]).to.deep.include.members([{ id: 1 }, {id: 2}]);")
	});

	it("Object with multiple properties", function() {
		assertify("expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');");
	});

	it("Simple Arrays", function() {
		assertify("expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);");
	});

	it("Deeply Nested Arrays", function() {
		assertify("expect([ [1, 2, 3],[ ['S', 'T', 'R'],['I'], 'N'], 4]).to.include.members([1, 2, 3]);");
	});

	it("Deeply nested objects", function() {
		assertify("expect({ two: { plus: { two: { is: four}}}}).to.have.property(two).that.is.an('object').that.deep.equals({ plus: { two: { is: four}}});")
	});

	it("Deeply nested mix", function() {
		assertify("expect([[ 'chai', 'matcha', 'konacha' ], [ { tea: 'chai' }, { tea: 'matcha' }, { tea: 'konacha' } ]]).to.have.deep.property('[0][1]', 'matcha');");
	});

	it("simple function execution as expect argument", function() {
		assertify("expect(obj.toString()).to.be.a('string');");
	});

	it("anonymous function body as arguments with no arguments", function() {
		assertify(new Buffer("expect(function(){return Bacon.retry({source: 'ugh'});}).to['throw'](\"'source' option has to be a function\");"));
	});

	it("anonymous function body as arguments with argument(s)", function() {
		assertify(new Buffer("expect(function(x, y){return Bacon.retry({source: x, code: y});}).to['throw'](\"'source' option has to be a function\");"));
	});

	it("named function body as arguments", function() {
		assertify(new Buffer("expect(Bacon.retry({source: function() {return Bacon.once(1);}}).toString()).to.equals(\"Bacon.retry({source:function})\");", 'utf8'));
	});

	it("Block Statement - function body by 'return'", function() {
		assertify(new Buffer("setTimeout(function(){return expect(function() {return Bacon.retry({source: \"ugh\"});}).to.throw(\"'source' option has to be a function\");},3000);",'utf8'));
	});

	it("parses MemberExpressions with Bracket notation", function() {
		assertify(new Buffer("setTimeout(function(){return expect(function() {return Bacon.retry({source: \"ugh\"});}).to[\"throw\"](\"'source' option has to be a function\");},3000);",'utf8'));
	});

	it("parses MemberExpressions with contiguous Bracket notations", function() {
		assertify(new Buffer("setTimeout(function(){return expect(function() {return Bacon.retry({source: \"ugh\"});})[\"to\"][\"throw\"](\"'source' option has to be a function\");},3000);",'utf8'));
	});

	it("parses New expressions", function() {
		assertify(new Buffer("setTimeout(function(){expect('x').to.be.ok;return setTimeout(function(){expect('a').to.be.ok;return new function(){expect('function').to.be.equal('function');return setTimeout(function(){}, 1000);};}, 2000);}, 3000);"), 'utf8');
	});

	it("parses New expressions with arguments", function() {
		assertify(new Buffer("setTimeout(function(){ return new function(x){ console.log(x);}(10);}, 3000);", 'utf8'));
	});

	it("Deeply Nested functions", function() {
		assertify("expect(setTimeout(function(){setTimeout(function(){}, 3000);}, 2000)).to.be.a[\"function\"];");
	});

	it("should not parse statements/expressions not starting with expect other than 'return'", function () {
		// TODO
	})

	it("Multiple Expect API lines", function() {
		assertify(new Buffer("expect(obj).to.have.property('foo').that.is.a('string');expect(deepObj).to.have.property('green').that.is.an('object').that.deep.equals({ tea: 'matcha' });expect(deepObj).to.have.property('teas').that.is.an('array').with.deep.property('[2]').that.deep.equals({ tea: 'konacha' });", 'utf8'));
	});
});


