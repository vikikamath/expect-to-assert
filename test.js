'use strict';
var esprima = require('esprima');
var traverse = require('./');
// var assert = require('assert');
var bufferSplit = require('buffer-split');
var chirp = require('./chirp');



describe("Validating traverse() correctly re-generates Expect API expressions from JSON generated by Esprima Parser", function() {

	/// Reusable functions


	function assertify(exprObj, test){
		return chirp.equal(traverse(exprObj), test);
	}

	// quickly assert a single line of Code
	function assertifySingleLineOfCode(line){
		return assertify(esprima.parse(line, {})['body'][0], line);
	}

	function assertifyMultipleLinesOfCode(lines){
		var linesArr = bufferSplit(lines, new Buffer('\r\n'));
		return esprima.parse(lines, {})['body'].every(function(e, i){
			// assures each expression statement is an element in 'body' array
			return assertify(e, linesArr[i].toString());
		});
	}

	///

	/// Tests


	it("Simple equality argument", function() {
		assertifySingleLineOfCode("expect(foo).to.equal('bar');");
	});

	it("Simple type argument", function() {
		assertifySingleLineOfCode("expect('test').to.be.a('string');");
	});

	it("Simple API that does not end in argument", function() {
		assertifySingleLineOfCode("expect(true).to.be.true;");
	});

	it("Simple property argument", function() {
		assertifySingleLineOfCode("expect(foo).to.have.length(3);");
	});

	it('Mutiple MemberExpressions and arguments', function(){
		assertifySingleLineOfCode("expect(tea).to.have.property('flavors').with.length(3);")
	});

	it("Test null", function() {
		assertifySingleLineOfCode("expect(null).to.be.a('null');")
	});

	it("Test undefined", function() {
		assertifySingleLineOfCode("expect(undefined).to.be.an('undefined');")
	});

	it("Simple Object argument", function() {
		assertifySingleLineOfCode("expect({ foo: 'bar' }).to.eql({ foo: 'bar' });");
	});

	it("Object nested in Array", function() {
		assertifySingleLineOfCode("expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);");
	});

	it("Object(s) nested in Array", function() {
		assertifySingleLineOfCode("expect([{ id: 1 }, {id: 2}]).to.deep.include.members([{ id: 1 }, {id: 2}]);")
	});

	it("Object with multiple properties", function() {
		assertifySingleLineOfCode("expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');");
	});

	it("Simple Arrays", function() {
		assertifySingleLineOfCode("expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);");
	});

	it("Deeply Nested Arrays", function() {
		assertifySingleLineOfCode("expect([ [1, 2, 3],[ ['S', 'T', 'R'],['I'], 'N'], 4]).to.include.members([1, 2, 3]);");
	});

	it("Deeply nested objects", function() {
		assertifySingleLineOfCode("expect({ two: { plus: { two: { is: four}}}}).to.have.property(two).that.is.an('object').that.deep.equals({ plus: { two: { is: four}}});")
	});

	it("Deeply nested mix", function() {
		assertifySingleLineOfCode("expect([[ 'chai', 'matcha', 'konacha' ], [ { tea: 'chai' }, { tea: 'matcha' }, { tea: 'konacha' } ]]).to.have.deep.property('[0][1]', 'matcha');");
	});

	it("simple function execution as expect argument", function() {
		assertifySingleLineOfCode("expect(obj.toString()).to.be.a('string');");
	});

	it("anonymous function body as arguments with no arguments", function() {
		assertifyMultipleLinesOfCode(new Buffer("expect(function(){return Bacon.retry({source: 'ugh'});}).to['throw'](\"'source' option has to be a function\");"));
	});

	it("anonymous function body as arguments with argument(s)", function() {
		assertifyMultipleLinesOfCode(new Buffer("expect(function(x, y){return Bacon.retry({source: x, code: y});}).to['throw'](\"'source' option has to be a function\");"));
	});

	it("named function body as arguments", function() {
		assertifyMultipleLinesOfCode(new Buffer("expect(Bacon.retry({source: function() {return Bacon.once(1);}}).toString()).to.equals(\"Bacon.retry({source:function})\");", 'utf-8'));
	});

	it("Block Statement - function body by 'return'", function() {
		assertifyMultipleLinesOfCode(new Buffer("setTimeout(function(){return expect(function() {return Bacon.retry({source: \"ugh\"});}).to.throw(\"'source' option has to be a function\");},3000);",'utf-8'));
	});

	it("parses MemberExpressions with Bracket notation", function() {
		assertifyMultipleLinesOfCode(new Buffer("setTimeout(function(){return expect(function() {return Bacon.retry({source: \"ugh\"});}).to[\"throw\"](\"'source' option has to be a function\");},3000);",'utf-8'));
	});

	it("parses MemberExpressions with contiguous Bracket notations", function() {
		assertifyMultipleLinesOfCode(new Buffer("setTimeout(function(){return expect(function() {return Bacon.retry({source: \"ugh\"});})[\"to\"][\"throw\"](\"'source' option has to be a function\");},3000);",'utf-8'));
	});

	it("Deeply Nested functions", function() {
		assertifySingleLineOfCode("expect(setTimeout(function(){setTimeout(function(){}, 3000);}, 2000)).to.be.a[\"function\"];");
	});

	it("should not parse statements/expressions not starting with expect other than 'return'", function () {
		// body...
	})

	it("Multiple Expect API lines", function() {
		assertifyMultipleLinesOfCode(new Buffer("expect(obj).to.have.property('foo').that.is.a('string');\r\nexpect(deepObj).to.have.property('green').that.is.an('object').that.deep.equals({ tea: 'matcha' });\r\nexpect(deepObj).to.have.property('teas').that.is.an('array').with.deep.property('[2]').that.deep.equals({ tea: 'konacha' });", 'utf-8'));
	});
});


